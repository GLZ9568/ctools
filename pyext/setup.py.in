from distutils.core import setup, Extension
from distutils import sysconfig
import glob
import os
import sys

# Removes list of bad prefixes from list
def remove_prefixes(optlist, bad_prefixes):
	for bad_prefix in bad_prefixes:
		for i, flag in enumerate(optlist):
			if flag.startswith(bad_prefix):
				optlist.pop(i)
				break
	return optlist

# Adjust compile options for darwin
if sys.platform.lower().startswith("darwin"):

	# Remove some time consuming options
	cvars = sysconfig.get_config_vars()
	cflags = cvars.get('OPT')
	if cflags:
		cflags = remove_prefixes(cflags.split(), 
		         ['-g', '-O', '-Wstrict-prototypes', '-DNDEBUG'])
	cvars['OPT'] = str.join(' ', cflags)
	cvars['CFLAGS'] = cvars['BASECFLAGS'] + ' ' + cvars['OPT']
	
	# Remove -arch flags. This prevents building a fat library
	cvars['ARCHFLAGS'] = ''
	
	# Signal darwin compiler adjustments
	print 'Adjust default distutils compiler options for darwin.'

# Remove any existing symbolic link to libctatools.a
# This will prevent any exception in creating the symbolic link due to
# an already existing link.
try:
	os.remove('../src/.libs/libctatools_python.a')
	print 'Removed ../src/.libs/libctatools_python.a'
except:
	pass

# Create a symbolic link. This allows us to enforce static linking instead of
# dynamic linking. We prefer here static linking to avoid any problems with
# finding the gammalib shared library during checking.
try:
	os.symlink('libctatools.a', '../src/.libs/libctatools_python.a')
	print 'Created ../src/.libs/libctatools_python.a'
	libcta='ctatools_python'
except:
	libcta='ctatool'

# Set default include directories and data files
include_dirs = ['@prefix@/include/gammalib']
data_files   = glob.glob('@top_srcdir@/pyext/*.i')
library_dirs = ['../src/.libs']
libraries    = [libcta,'gamma']

# Append prefix library directory if it exists and set default runtime
# library directories
if os.path.exists('@prefix@/lib'):
	library_dirs.append(['@prefix@/lib'])
	runtime_library_dirs = ['@prefix@/lib']
else:
	runtime_library_dirs = []	

# Add application include files. The method we use here is not very
# intelligent as it simple will add all names that start with 'ct'
# in the src directory. Once we added the ctatools script we had to
# add an explicit filter to avoid appending those.
dirs = glob.glob('../src/ct*')
for dir in dirs:
	if len(dir) > 0 and 'ctatools' not in dir:
		path = os.path.abspath(dir)
		include_dirs.append(path)

# Add extra libraries
extra_libs = ('@PYTHON_EXTRA_LIBS@').split(',')
for extra_lib in extra_libs:
	if len(extra_lib) > 0:
		libraries.append(extra_lib)

# Get extra library paths
extra_lib_paths = ('@LDFLAGS@').split(' ')
for extra_lib_path in extra_lib_paths:
	if extra_lib_path.lstrip().find('-L') != -1:
		dir = extra_lib_path.lstrip().lstrip('-L')
		if len(dir) > 0:
			library_dirs.append(dir)

# Get extra include directories
extra_include_dirs = ('@CPPFLAGS@').split(' ')
for extra_include_dir in extra_include_dirs:
	if extra_include_dir.lstrip().find('-I') != -1:
		dir = extra_include_dir.lstrip().lstrip('-I')
		if len(dir) > 0:
			include_dirs.append(dir)

# Setup
setup(name='@PACKAGE_NAME@',
      version='@PACKAGE_VERSION@',
      description='ctatools Python binding',
      author='Jurgen Knodlseder',
      author_email='@PACKAGE_BUGREPORT@',
      url='http://gammalib.sourceforge.net/',
      py_modules=['ctatools'],
      ext_modules=[Extension('_ctatools', ['ctatools_wrap.cpp'],
                             include_dirs=include_dirs,
                             library_dirs=library_dirs,
                             libraries=libraries,
                             runtime_library_dirs=runtime_library_dirs)],
     )
